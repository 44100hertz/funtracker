* Song Architecture
** Data Types
*** Numbers
Numbers are decimal floating-point numbers, counting from 1.

~8m, 8c, .8, 8, 80, 8h, 8k~ are all possible power levels, in order.
They're stackable; ~.1m~ considered valid, etc.
Using only + or - will increment or decrement the value.
Numbers default to 0 unless otherwise specified.

*** Bools
 - ~y/t/1~ true
 - ~n/f/0~ false
 - will always normalize to 0/1 after entry

*** id's
An id is short for a string name.
Non-base32 chars are ignored.
If you want to make an instrument unique, you can number it.
Non-entered id's default to "0".

examples
#+BEGIN_EXAMPLE
"piano"
  p, pi, pia, ... = piano

"that", "this" <--bad names
  t, th, ... = that
  thi, ... = this

"0that", "1this"
  0 = 0that
  1 = 1this
#+END_EXAMPLE
** Samples
Samples are headerless mono signed PCM in a separate file.

** Instruments
Instruments are commands that replace any part of the channel state.
They can have arbitrary precision/size; for example 48.3002 is valid here.

Example
#+BEGIN_EXAMPLE
  init: 3 41h 548k 6 7 8 9 g ha-
  note: p a50
#+END_EXAMPLE

Inferred meaning
#+BEGIN_EXAMPLE
init          ; do the following on instrument load
  30 4100     ; 100 long sample at 0
  548000      ; sample rate 48khz
  60 7100     ; loop entire sample
  8f          ; loop forward
  8100        ; no volume adjustment
  gc001 ha-01 ; patch to ramp volume down over 1 second

note          ; do the folowing on each note played
  p0          ; play from start of sample
  a50         ; start at 50% mixer volume
#+END_EXAMPLE

** Macros
A list of note macros is defined for each song.
Macros are executed at one tick per command.

Syntax
#+BEGIN_EXAMPLE
[num]  single-digit numbers play a note at base note + n, then tick
.n     tick n times; default 1
+n     add n to the base note; default 1
-n     subtract n from the base note; default 1
>      add half an octave to the base note
<      subtract half an octave from the base note
n      new note before next tick
o      note off after next tick
k      note off after next tick, end macro here
e      end macro (otherwise repeat)
#+END_EXAMPLE

Examples
#+BEGIN_EXAMPLE
037      arpeggio triplet
<037     lower triplet
n        repeat note forever
k        delay note off by 1
.k       delay note off by 2
+1       glissando up
-1       glissando down
#+END_EXAMPLE

** Song data
Songs are stored in a whitespace-aware plaintext.
They're almost exactly what you see in the tracker.
See example-song for what they could look like.

*** Patterns
Every pattern of a song has a name that's referencable as an id.

Command format ~N-O / cXXXX~
#+BEGIN_EXAMPLE
N   note letter
O   octave
c   the base id; what to modify
X   4 chars of params
#+END_EXAMPLE

*** Order
Syntax
#+BEGIN_EXAMPLE
[id]    which order to play
[       start of loop
]       end of loop
#+END_EXAMPLE

Examples
#+BEGIN_EXAMPLE
[ a b a c ]    traditional song structure
intro [body]   a song with an intro and body
#+END_EXAMPLE
** List of Commands/Params
*** Internal
~0n~ live channel *0utput*. Set by song if ~{4}~ > 0 and ~{5}~ > 0.

~1i~ load *1nstrument*. Sets and initializes. Default ~{2}~

~2i~ set instrument. Sets w/o initializing.

~3n~ sample offset in points.

~4n~ sample length.

~5n~ sample rate. Controls how quickly phase ~{p}~ increases.
Default 16000.

~6n~ loop start relative to sample offset ~{3}~.

~7n~ loop length. Default is sample length ~{4}~.

~8L~ loop type. f=forward (default); p=pingpong; b=backward.

~9n~ volume base multiplier = n / 100. Default 100 = 1x

*** Playback
~An~ *Amplitude*; mixer volume. Ratio = n / 800. Default 100=1/8.

~Dn~ panning *Direction*. d100=fully right, d-100 = fully left.

~Tn~ *Tuning* adjustment. t100=full note up.

~Pn~ live *Phase* in points. Set if ~{4}~ > 0  and ~{5}~ > 0.

~Nn~ whole *Note* pitch, typically set by note column. Rounds to integers.

~CM~ *Create* new macro M and run it here.

~Mi~ run premade *Macro* i.

*** Patches
Patches use a set of input/output fixed pairs: ~ef / gh / jk~.
Input data is read to each respective output per-sample.

~[E/G/J]*~ Input
#+BEGIN_EXAMPLE
Cn      constant value n (default 1)
[num]d  channel num, delay d in ms
Ad      the final mix, delay d in ms
Ln      an LFO n ticks per sample
#+END_EXAMPLE

~[F/H/K]O*~ Output
#+BEGIN_EXAMPLE
 O   output param to modify
 *   modify method
   wn   output = wet/dry mix;  0=dry, 100=wet; default=50
   >n   output = base + input * n/100
   <n   output = base - input * n/100
   =n   base = input * n/100; default 100=1.0
   +n   base = base + input * n/sample rate, default 1 = 1 second from 0 -> 1
   -n   base = base - input * n/sample rate, default 1 = 1 second from 1 -> 0
#+END_EXAMPLE
Things that modify the base will repeatedly and instantly modify.
This is affected by sample rate, and is divided by it for consistency.
However, things that modify output do so right before mixing, and cannot be stacked.

Examples
#+BEGIN_EXAMPLE
~G.... Ha-..~ volume slide down 1/10000 per point
~G0... Hp...~ total phase modulation from channel 0
~G0... Htw20~ frequency modulation from channel 0
~G01k. H0w10~ mix 1000-sample delayed channel 0 into self
#+END_EXAMPLE

*** Channel Misc
~Wn~ sample rate at which to grab history, default 16000

~XCb~ *Clipping* mode for mixer, 1=limit to [-1, 1]

*** Control
~JRn~ next *row jump*

~JPn~ next *pattern jump*

~Bn~ song *BPM*

~Rn~ set speed *rate* in ticks per row

~Vn~ global *volume*

*** Unused
~uyl+-~ What could they be for?
